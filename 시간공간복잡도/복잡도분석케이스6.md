# 코드 (퀵 정렬)

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x < pivot]
    equal = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + equal + quick_sort(right)
```

## 간략히 분석
- 시간복잡도: 재귀문이므로 O(log n), 그리고 그 안에 for문이 있으므로 O(n) -> O(n log n), 최선은 이미 정렬된 경우 한 번만 탐색하여 O(n)
- 공간복잡도: left, equal, right 리스트를 새로 만듬. 따라서 O(n)
