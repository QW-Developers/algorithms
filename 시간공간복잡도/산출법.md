# 시간 공간 복잡도 산출법

## 시간 복잡도(Time Complexity)

시간복잡도는 알고리즘이 수행하는 기본 연산 횟수를 입력 크기 n의 함수로 나타낸 것이며 산출은 다음과 같다.

1. 기본 단위 연산 정의
  예: 비교(if), 대임(=), 산술연산(+,-), 반복문의 1회 실행 등
2. 반복문 분석
   - for i in range(n): -> O(n)
   - 중첩 루프 -> O(n^2)
   - 절반씩 줄어드는 루프(예: 이진 탐색) -> O(log n)
3. 조건문 분석
   - if/else 문 자체는 O(1),
   - 하지만 분기마다 다른 복잡도를 갖는 경우 최악/평균을 따로 계산
4. 함수 호출/재귀 분석
   - 재귀 호출 횟수 x 각 호출의 연산량
   - 예: 피보나치 재귀 -> T(n) = T(n-1) + T(n-2) -> O(2^n)
5. 전체 합산 후 Big-O로 단순화
   - 낮은 차수/상수항은 제거 -> O(n^2 + n + 1) -> O(n^2)
  
## 공간 복잡도(Space Complexity)

공간복잠도는 알고리즘이 사용하는 메모리 크기를 입력 크기 n에 대한 함수로 나타낸 것입니다.

산출 과정은:
1. 고정 공간(Fixed part)
   - 코드, 상수, 기본 변수 크기 -> O(1)
2. 가변 공간(Variable part)
   - 입력 데이터 저장 공간 -> O(n)
   - 추가 자료구조(배열, 리스트, 스택 등) -> 크기에 따라 O(n), O(n^2) 등
   - 재귀 함수의 호출 스택 -> 깊이에 따라 O(n) 등
3. 전체 합산 후 Big-O 표기
   - 예: Merge Sort -> 입력 배열 O(n) + 임시 배열 O(n) + 재귀 스택 O(log n) -> O(n)
  
## 예시

(1) 선형 탐색

```python
def linear_search(arr, x):
  for i in range(len(arr)):
    if arr[i] == x:
      return i
  return -1
```
- 시간복잡도: O(n) (최악: 끝까지 검색)
- 공간복잡도: O(1) (입력 외 추가 메모리 거의 없음)

(2) Merge Sort
- 시간복잡도: O(n log n) (분할 O(log n), 병합 O(n))
- 공간복잡도: O(n) (임시 배열 필요)




