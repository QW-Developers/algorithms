# 코드(삽입 정렬)

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr
```

## 간략히 분석
- 시간복잡도: for 문 안에 while문이 중첩되어 있다. -> 최악 O(n^2), 최선은 이미 정렬된 경우 O(n) -> 따라서 O(n^2)
- 공간복잡도: 제자리 교체를 하고 있다. 따라서 추가적인 메모리가 들지 않으므로 O(1)

## 꼼꼼히 분석
- 위와 동일.
